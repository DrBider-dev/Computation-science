/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package View;

import java.awt.*;
import java.io.File;
import java.io.PrintWriter;
import java.util.Scanner;
import javax.swing.*;
import javax.swing.border.LineBorder;


/**
 *
 * @author Brayan
 */
public class HashingSearch extends javax.swing.JFrame {
    
    private static final java.util.logging.Logger logger = java.util.logging.Logger.getLogger(HashingSearch.class.getName());
    
    private static final Color BG = new Color(255, 255, 255);
    private static final Color MINT = new Color(124, 212, 187);
    private static final Color LABEL_BLACK = Color.black;
    private static final int CELL_WIDTH = 100;
    private static final int CELL_HEIGHT = 70;
    private Integer longitudClavesMod, longitudClavesSqr, longitudClavesFold, longitudClavesTrunk = null; 

    
    private Integer[] arrayMod, arraySqr, arrayFold, arrayTrunk; // modelo del arreglo (null = vacío)
    
    int xMouse, yMouse;
    
    private static HashingSearch instance;
    
    public static HashingSearch getInstance() {
        if (instance == null) {
            instance = new HashingSearch();
        }
        return instance;
    }

    /**
     * Creates new form LinealSearch
     */
    public HashingSearch() {
        setNimbusLookAndFeel();
        initComponents();
        initArrayVisualizer();
    }
    
    private void setNimbusLookAndFeel() {
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ReflectiveOperationException | javax.swing.UnsupportedLookAndFeelException ex) {
            logger.log(java.util.logging.Level.SEVERE, null, ex);
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        backGround = new javax.swing.JPanel();
        logo = new javax.swing.JLabel();
        volverTxt = new javax.swing.JLabel();
        dragPanel = new javax.swing.JPanel();
        scrollPaneCells = new javax.swing.JScrollPane();
        panelCells = new javax.swing.JPanel();
        jPanel1 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        txtArraySize = new javax.swing.JLabel();
        sizeArrayField = new javax.swing.JTextField();
        btnCreate = new javax.swing.JButton();
        txtKeySize = new javax.swing.JLabel();
        sizeKeyField = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        txtValor = new javax.swing.JLabel();
        txtKey = new javax.swing.JTextField();
        btnInsert = new javax.swing.JButton();
        btnSearch = new javax.swing.JButton();
        btnDelete = new javax.swing.JButton();
        btnSave = new javax.swing.JButton();
        btnOpen = new javax.swing.JButton();
        hashCombo = new javax.swing.JComboBox<>();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Hash&Seek");
        setLocationByPlatform(true);
        setUndecorated(true);
        getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        backGround.setBackground(new java.awt.Color(255, 255, 255));
        backGround.setForeground(new java.awt.Color(0, 0, 0));
        backGround.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        logo.setFont(new java.awt.Font("Calibri", 3, 48)); // NOI18N
        logo.setForeground(new java.awt.Color(124, 212, 187));
        logo.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        logo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Assets/HashModTitle.png"))); // NOI18N
        backGround.add(logo, new org.netbeans.lib.awtextra.AbsoluteConstraints(230, 20, 840, 120));

        volverTxt.setFont(new java.awt.Font("Cambria Math", 0, 48)); // NOI18N
        volverTxt.setForeground(new java.awt.Color(0, 0, 0));
        volverTxt.setText("< Volver");
        volverTxt.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        volverTxt.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                volverTxtMouseClicked(evt);
            }
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                volverTxtMouseEntered(evt);
            }
            public void mouseExited(java.awt.event.MouseEvent evt) {
                volverTxtMouseExited(evt);
            }
        });
        backGround.add(volverTxt, new org.netbeans.lib.awtextra.AbsoluteConstraints(30, 80, -1, -1));

        dragPanel.setBackground(new java.awt.Color(255, 255, 255));
        dragPanel.setCursor(new java.awt.Cursor(java.awt.Cursor.MOVE_CURSOR));
        dragPanel.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                dragPanelMouseDragged(evt);
            }
        });
        dragPanel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                dragPanelMousePressed(evt);
            }
        });

        javax.swing.GroupLayout dragPanelLayout = new javax.swing.GroupLayout(dragPanel);
        dragPanel.setLayout(dragPanelLayout);
        dragPanelLayout.setHorizontalGroup(
            dragPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1280, Short.MAX_VALUE)
        );
        dragPanelLayout.setVerticalGroup(
            dragPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 50, Short.MAX_VALUE)
        );

        backGround.add(dragPanel, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, 1280, 50));

        panelCells.setBackground(new java.awt.Color(255, 255, 255));
        scrollPaneCells.setViewportView(panelCells);

        backGround.add(scrollPaneCells, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 340, 1250, 360));

        jPanel1.setBackground(new java.awt.Color(102, 153, 255));

        jLabel2.setFont(new java.awt.Font("Cambria Math", 1, 24)); // NOI18N
        jLabel2.setForeground(new java.awt.Color(0, 0, 0));
        jLabel2.setText("Crear estructura");

        txtArraySize.setForeground(new java.awt.Color(0, 0, 0));
        txtArraySize.setText("Tamaño:");

        sizeArrayField.setBackground(new java.awt.Color(255, 255, 255));
        sizeArrayField.setForeground(new java.awt.Color(0, 0, 0));
        sizeArrayField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sizeArrayFieldActionPerformed(evt);
            }
        });

        btnCreate.setBackground(new java.awt.Color(51, 51, 51));
        btnCreate.setFont(new java.awt.Font("Cambria Math", 1, 18)); // NOI18N
        btnCreate.setForeground(new java.awt.Color(255, 255, 255));
        btnCreate.setText("Crear");
        btnCreate.setBorder(null);
        btnCreate.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnCreate.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                btnCreateMouseEntered(evt);
            }
            public void mouseExited(java.awt.event.MouseEvent evt) {
                btnCreateMouseExited(evt);
            }
        });
        btnCreate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCreateActionPerformed(evt);
            }
        });

        txtKeySize.setForeground(new java.awt.Color(0, 0, 0));
        txtKeySize.setText("Tamaño de la Clave:");

        sizeKeyField.setBackground(new java.awt.Color(255, 255, 255));
        sizeKeyField.setForeground(new java.awt.Color(0, 0, 0));
        sizeKeyField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sizeKeyFieldActionPerformed(evt);
            }
        });

        jLabel3.setFont(new java.awt.Font("Cambria Math", 1, 24)); // NOI18N
        jLabel3.setForeground(new java.awt.Color(0, 0, 0));
        jLabel3.setText("Insertar, Buscar o Eliminar Clave");

        txtValor.setForeground(new java.awt.Color(0, 0, 0));
        txtValor.setText("clave:");

        txtKey.setBackground(new java.awt.Color(255, 255, 255));
        txtKey.setForeground(new java.awt.Color(0, 0, 0));

        btnInsert.setBackground(new java.awt.Color(51, 51, 51));
        btnInsert.setFont(new java.awt.Font("Cambria Math", 1, 18)); // NOI18N
        btnInsert.setForeground(new java.awt.Color(255, 255, 255));
        btnInsert.setText("Insertar");
        btnInsert.setBorder(null);
        btnInsert.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnInsert.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                btnInsertMouseEntered(evt);
            }
            public void mouseExited(java.awt.event.MouseEvent evt) {
                btnInsertMouseExited(evt);
            }
        });
        btnInsert.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnInsertActionPerformed(evt);
            }
        });

        btnSearch.setBackground(new java.awt.Color(51, 51, 51));
        btnSearch.setFont(new java.awt.Font("Cambria Math", 1, 18)); // NOI18N
        btnSearch.setForeground(new java.awt.Color(255, 255, 255));
        btnSearch.setText("Buscar");
        btnSearch.setBorder(null);
        btnSearch.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnSearch.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                btnSearchMouseEntered(evt);
            }
            public void mouseExited(java.awt.event.MouseEvent evt) {
                btnSearchMouseExited(evt);
            }
        });

        btnDelete.setBackground(new java.awt.Color(51, 51, 51));
        btnDelete.setFont(new java.awt.Font("Cambria Math", 1, 18)); // NOI18N
        btnDelete.setForeground(new java.awt.Color(255, 255, 255));
        btnDelete.setText("Eliminar");
        btnDelete.setBorder(null);
        btnDelete.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnDelete.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                btnDeleteMouseEntered(evt);
            }
            public void mouseExited(java.awt.event.MouseEvent evt) {
                btnDeleteMouseExited(evt);
            }
        });

        btnSave.setBackground(new java.awt.Color(51, 51, 51));
        btnSave.setFont(new java.awt.Font("Cambria Math", 1, 18)); // NOI18N
        btnSave.setForeground(new java.awt.Color(255, 255, 255));
        btnSave.setText("Guardar");
        btnSave.setBorder(null);
        btnSave.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnSave.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                btnSaveMouseEntered(evt);
            }
            public void mouseExited(java.awt.event.MouseEvent evt) {
                btnSaveMouseExited(evt);
            }
        });

        btnOpen.setBackground(new java.awt.Color(51, 51, 51));
        btnOpen.setFont(new java.awt.Font("Cambria Math", 1, 18)); // NOI18N
        btnOpen.setForeground(new java.awt.Color(255, 255, 255));
        btnOpen.setText("Recuperar");
        btnOpen.setBorder(null);
        btnOpen.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnOpen.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                btnOpenMouseEntered(evt);
            }
            public void mouseExited(java.awt.event.MouseEvent evt) {
                btnOpenMouseExited(evt);
            }
        });

        hashCombo.setBackground(new java.awt.Color(51, 51, 51));
        hashCombo.setFont(new java.awt.Font("Cambria Math", 1, 18)); // NOI18N
        hashCombo.setForeground(new java.awt.Color(255, 255, 255));
        hashCombo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "H. Mod", "H. Cuadrado", "H. Plegamiento", "H. Truncamiento" }));

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(15, 15, 15)
                .addComponent(hashCombo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(33, 33, 33)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(txtArraySize)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(sizeArrayField, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtKeySize)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(sizeKeyField, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(79, 79, 79)
                        .addComponent(jLabel2))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(116, 116, 116)
                        .addComponent(btnCreate, javax.swing.GroupLayout.PREFERRED_SIZE, 98, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(51, 51, 51)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(49, 49, 49)
                        .addComponent(btnInsert, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(26, 26, 26)
                        .addComponent(btnSearch, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(18, 18, 18)
                        .addComponent(btnDelete, javax.swing.GroupLayout.PREFERRED_SIZE, 102, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(22, 22, 22))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(txtValor)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtKey, javax.swing.GroupLayout.PREFERRED_SIZE, 382, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(50, 50, 50)
                        .addComponent(jLabel3)))
                .addGap(74, 74, 74)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(btnSave, javax.swing.GroupLayout.PREFERRED_SIZE, 129, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnOpen, javax.swing.GroupLayout.PREFERRED_SIZE, 129, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(140, 140, 140))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(16, 16, 16)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel2)
                            .addComponent(hashCombo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(txtArraySize, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(sizeArrayField, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtKeySize, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(sizeKeyField, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(btnCreate, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel3)
                            .addComponent(btnSave, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(txtKey, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtValor, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(btnDelete, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(btnSearch, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(btnInsert, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(btnOpen, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap(15, Short.MAX_VALUE))
        );

        backGround.add(jPanel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 150, 1260, 170));

        getContentPane().add(backGround, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, 1280, 720));

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void volverTxtMouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_volverTxtMouseEntered
        volverTxt.setForeground(new Color(124, 212, 187));
    }//GEN-LAST:event_volverTxtMouseEntered

    private void volverTxtMouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_volverTxtMouseExited
        volverTxt.setForeground(Color.black);
    }//GEN-LAST:event_volverTxtMouseExited

    private void volverTxtMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_volverTxtMouseClicked
        this.setVisible(false);
        PrincipalPage.getInstance().setVisible(true);
    }//GEN-LAST:event_volverTxtMouseClicked

    private void dragPanelMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_dragPanelMousePressed
        xMouse = evt.getX();
        yMouse = evt.getY();
    }//GEN-LAST:event_dragPanelMousePressed

    private void dragPanelMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_dragPanelMouseDragged
        int x = evt.getXOnScreen();
        int y = evt.getYOnScreen();
        this.setLocation(x - xMouse, y - yMouse);
    }//GEN-LAST:event_dragPanelMouseDragged

    private void sizeArrayFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sizeArrayFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_sizeArrayFieldActionPerformed

    private void btnCreateMouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnCreateMouseEntered
        btnCreate.setForeground(MINT);
    }//GEN-LAST:event_btnCreateMouseEntered

    private void btnCreateMouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnCreateMouseExited
        btnCreate.setForeground(Color.WHITE);
    }//GEN-LAST:event_btnCreateMouseExited

    private void btnCreateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCreateActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_btnCreateActionPerformed

    private void sizeKeyFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sizeKeyFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_sizeKeyFieldActionPerformed

    private void btnInsertMouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnInsertMouseEntered
        btnInsert.setForeground(MINT);
    }//GEN-LAST:event_btnInsertMouseEntered

    private void btnInsertMouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnInsertMouseExited
        btnInsert.setForeground(Color.WHITE);
    }//GEN-LAST:event_btnInsertMouseExited

    private void btnInsertActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnInsertActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_btnInsertActionPerformed

    private void btnSearchMouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnSearchMouseEntered
        btnSearch.setForeground(MINT);
    }//GEN-LAST:event_btnSearchMouseEntered

    private void btnSearchMouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnSearchMouseExited
        btnSearch.setForeground(Color.WHITE);
    }//GEN-LAST:event_btnSearchMouseExited

    private void btnDeleteMouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnDeleteMouseEntered
        btnDelete.setForeground(MINT);
    }//GEN-LAST:event_btnDeleteMouseEntered

    private void btnDeleteMouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnDeleteMouseExited
        btnDelete.setForeground(Color.WHITE);
    }//GEN-LAST:event_btnDeleteMouseExited

    private void btnSaveMouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnSaveMouseEntered
        // TODO add your handling code here:
    }//GEN-LAST:event_btnSaveMouseEntered

    private void btnSaveMouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnSaveMouseExited
        // TODO add your handling code here:
    }//GEN-LAST:event_btnSaveMouseExited

    private void btnOpenMouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnOpenMouseEntered
        // TODO add your handling code here:
    }//GEN-LAST:event_btnOpenMouseEntered

    private void btnOpenMouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnOpenMouseExited
        // TODO add your handling code here:
    }//GEN-LAST:event_btnOpenMouseExited

    /**
     * @param args the command line arguments
     */
    
    //METODOS PROPIOS
    
    private void initArrayVisualizer() {
        // fondo y estilo general
        getContentPane().setBackground(BG);
        // panelCells es el JPanel creado en el diseñador (dentro de scrollPaneCells)
        panelCells.setBackground(BG);
        panelCells.setOpaque(false);

        // usar BoxLayout horizontal para que las celdas queden en fila
        panelCells.setLayout(new BoxLayout(panelCells, BoxLayout.X_AXIS));
        scrollPaneCells.getViewport().setBackground(BG);
        scrollPaneCells.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        scrollPaneCells.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);

        // Asignar listeners a botones (si prefieres el diseñador, crea los actionPerformed y solo llama a onCreateArray() etc.)
        btnCreate.addActionListener(_ -> onCreateArray());
        btnInsert.addActionListener(_ -> onInsert());
        btnSearch.addActionListener(_ -> onSearch());
        btnDelete.addActionListener(_ -> onDelete());

        // Botones de guardado y importacion de archivo
        btnSave.addActionListener(_ -> guardarArrays());
        btnOpen.addActionListener(_ -> {
            abrirArrays();
            refreshCellsUI();
        });
        hashCombo.addActionListener(_ -> {
            setIcon();
            refreshCellsUI();
        });
        
        
    }
    
    
    // --------- Guardado y Recuperacion de Archivos ----------------------------
    
    private void guardarArrays() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setFileFilter(new javax.swing.filechooser.FileNameExtensionFilter("Archivos de Búsqueda Hash Mod", "mod"));

        int option = fileChooser.showSaveDialog(this);
        if (option == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();

            // Asegurar extensión .mod
            if (!file.getName().toLowerCase().endsWith(".mod")) {
                file = new File(file.getParentFile(), file.getName() + ".mod");
            }

            try (PrintWriter writer = new PrintWriter(file)) {
                // Guardar las longitudes de claves en las primeras 4 líneas
                writer.println(longitudClavesMod != null ? longitudClavesMod : "");
                writer.println(longitudClavesSqr != null ? longitudClavesSqr : "");
                writer.println(longitudClavesFold != null ? longitudClavesFold : "");
                writer.println(longitudClavesTrunk != null ? longitudClavesTrunk : "");
                
                // Guardar cada array con un separador y luego sus elementos
                guardarArray(writer, "MOD", arrayMod);
                guardarArray(writer, "SQR", arraySqr);
                guardarArray(writer, "FOLD", arrayFold);
                guardarArray(writer, "TRUNK", arrayTrunk);
                
                JOptionPane.showMessageDialog(this, "Archivo guardado correctamente.");
            } catch (Exception e) {
                JOptionPane.showMessageDialog(this, "Error al guardar: " + e.getMessage(),
                        "Error", JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    // Método auxiliar para guardar un array individual
    private void guardarArray(PrintWriter writer, String nombreArray, Integer[] array) {
        writer.println("---" + nombreArray + "---");
        if (array != null) {
            for (Integer num : array) {
                if (num == null) {
                    writer.println("");
                } else {
                    writer.println(num);
                }
            }
        }
        writer.println("---END " + nombreArray + "---");
    }

    private void abrirArrays() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setFileFilter(new javax.swing.filechooser.FileNameExtensionFilter("Archivos de Búsqueda Hash Mod", "mod"));

        int option = fileChooser.showOpenDialog(this);
        if (option == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();

            // Validar que el archivo tenga la extensión correcta
            if (!file.getName().toLowerCase().endsWith(".mod")) {
                JOptionPane.showMessageDialog(this, "El archivo seleccionado no corresponde a una búsqueda Hash Mod.",
                        "Extensión incorrecta", JOptionPane.WARNING_MESSAGE);
                return;
            }

            try (Scanner scanner = new Scanner(file)) {
                // Leer las longitudes de claves (primeras 4 líneas)
                if (scanner.hasNextLine()) longitudClavesMod = parsearEntero(scanner.nextLine().trim());
                if (scanner.hasNextLine()) longitudClavesSqr = parsearEntero(scanner.nextLine().trim());
                if (scanner.hasNextLine()) longitudClavesFold = parsearEntero(scanner.nextLine().trim());
                if (scanner.hasNextLine()) longitudClavesTrunk = parsearEntero(scanner.nextLine().trim());
                
                // Leer los arrays
                arrayMod = leerArray(scanner, "MOD");
                arraySqr = leerArray(scanner, "SQR");
                arrayFold = leerArray(scanner, "FOLD");
                arrayTrunk = leerArray(scanner, "TRUNK");
                
                JOptionPane.showMessageDialog(this, "Archivo cargado correctamente.");
            } catch (Exception e) {
                JOptionPane.showMessageDialog(this, "Error al abrir: " + e.getMessage(),
                        "Error", JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    // Método auxiliar para parsear enteros (maneja strings vacíos)
    private Integer parsearEntero(String texto) {
        if (texto == null || texto.isEmpty()) {
            return null;
        }
        try {
            return Integer.parseInt(texto);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    // Método auxiliar para leer un array individual
    private Integer[] leerArray(Scanner scanner, String nombreArray) {
        java.util.List<Integer> lista = new java.util.ArrayList<>();
        
        // Buscar el inicio del array
        while (scanner.hasNextLine()) {
            String linea = scanner.nextLine().trim();
            if (linea.equals("---" + nombreArray + "---")) {
                break;
            }
        }
        
        // Leer los elementos hasta encontrar el fin del array
        while (scanner.hasNextLine()) {
            String linea = scanner.nextLine().trim();
            if (linea.equals("---END " + nombreArray + "---")) {
                break;
            }
            
            if (!linea.isEmpty()) {
                lista.add(Integer.parseInt(linea));
            } else {
                lista.add(null);
            }
        }
        
        return lista.toArray(new Integer[0]);
    }

    
    // --------- OPERACIONES (Crea/Insertar/Buscar/Modificar/Eliminar) ----------
    private void onCreateArray() {
        try {
            String selected = (String) hashCombo.getSelectedItem();
            int size = Math.max(1, Integer.parseInt(sizeArrayField.getText().trim()));
            int keyLen = Math.max(1, Integer.parseInt(sizeKeyField.getText().trim()));

            switch (selected) {
                case "H. Mod":
                    arrayMod = new Integer[size];
                    longitudClavesMod = keyLen;
                    break;
                case "H. Cuadrado":
                    arraySqr = new Integer[size];
                    longitudClavesSqr = keyLen;
                    break;
                case "H. Plegamiento":
                    arrayFold = new Integer[size];
                    longitudClavesFold = keyLen;
                    break;
                case "H. Truncamiento":
                    arrayTrunk = new Integer[size];
                    longitudClavesTrunk = keyLen;
                    break;
            }
            refreshCellsUI();
        } catch (NumberFormatException ex) {
            JOptionPane.showMessageDialog(this, "Tamaño inválido", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    // Métodos de Hashing

    public static int modHash(int clave, int tamañoArreglo) {
        return clave % tamañoArreglo;
    }

    public static int middleSquareHash(int clave, int tamañoArreglo) {
        
        long square = (long) clave * clave;
        String squareTxt = Long.toString(square);

        int length = String.valueOf(tamañoArreglo).length(); 
        int need = length - 1; // cantidad de dígitos centrales requeridos

        // índice de inicio: punto medio - la mitad de los dígitos que necesito
        int start = (squareTxt.length() - need) / 2;
        int end = start + need;

        String hash = squareTxt.substring(start, end);
        
        return Integer.valueOf(hash);
    }

    public static int truncationHash(int clave, int tamañoArreglo) {
        String claveTxt = String.valueOf(clave);

        // cantidad de dígitos necesarios = número de dígitos del tamaño del arreglo - 1
        int digitsNeeded = String.valueOf(tamañoArreglo).length() - 1;
        if (digitsNeeded <= 0) digitsNeeded = 1;

        // si la clave tiene menos dígitos de los necesarios, se usa tal cual
        String part;
        if (claveTxt.length() <= digitsNeeded) {
            part = claveTxt;
        } else {
            // tomamos los últimos 'digitsNeeded' dígitos de la clave
            part = claveTxt.substring(claveTxt.length() - digitsNeeded);
        }

        int index = Integer.parseInt(part) % tamañoArreglo;
        
        
        return index;
    }

    public static int foldingHash(int clave, int tamañoArreglo) {
        String claveTxt = String.valueOf(clave);

        int groupSize = String.valueOf(tamañoArreglo).length() - 1;
        if (groupSize <= 0) groupSize = 1;

        int sum = 0;
        for (int i = 0; i < claveTxt.length(); i += groupSize) {
            int end = Math.min(i + groupSize, claveTxt.length());
            String group = claveTxt.substring(i, end);
            sum += Integer.parseInt(group);
        }

        int index = sum % tamañoArreglo;
        return index;
    }

    // Operaciones de Inserción, Búsqueda y Eliminación

    private void onInsert() {
        try {
            // Determinar qué array estamos usando según el método activo
            String metodoActual = hashCombo.getSelectedItem().toString();
            String input = txtKey.getText().trim();
            int key = Integer.parseInt(input);
            int n, index;

            switch(metodoActual) {
                case "H. Mod":
                    if (arrayMod == null) {
                        JOptionPane.showMessageDialog(this, "Por Favor cree la Estructura para " 
                        + metodoActual, "Estructura no creada", JOptionPane.WARNING_MESSAGE);
                        return;
                    }

                    // 1. validar longitud de la clave
                    if (longitudClavesMod == null) {
                        JOptionPane.showMessageDialog(this, "Longitud no definida");
                    } else if (input.length() != longitudClavesMod) {
                        JOptionPane.showMessageDialog(this,
                            "Todas las claves deben tener " + longitudClavesMod + " dígitos",
                            "Longitud inválida",
                            JOptionPane.WARNING_MESSAGE);
                        return;
                    }

                    n = arrayMod.length;
                    index = modHash(key, n);

                    // 2. validar si la clave ya existe (no claves repetidas)
                    if (arrayMod[index] != null && arrayMod[index] == key) {
                        JOptionPane.showMessageDialog(this,
                            "La clave " + key + " ya existe en la tabla de " + metodoActual,
                            "Clave repetida",
                            JOptionPane.WARNING_MESSAGE);
                        return;
                    } else if (arrayMod[index] == null) {
                        // 3. insertar si no hay colisión
                        arrayMod[index] = key;
                        refreshCellsUI();
                        JOptionPane.showMessageDialog(this,
                            "Clave " + key + " insertada correctamente en " + metodoActual,
                            "Inserción exitosa",
                            JOptionPane.INFORMATION_MESSAGE);
                    } else {
                        refreshCellsUI();
                        JOptionPane.showMessageDialog(this,
                            "No se pudo insertar, colisión en la posición " + (index + 1) + " para " + metodoActual,
                            "Colisión",
                            JOptionPane.WARNING_MESSAGE);
                    }
                    break;
                case "H. Cuadrado":
                    if (arraySqr == null) {
                        JOptionPane.showMessageDialog(this, "Por Favor cree la Estructura para " 
                        + metodoActual, "Estructura no creada", JOptionPane.WARNING_MESSAGE);
                        return;
                    }

                    // 1. validar longitud de la clave
                    if (longitudClavesSqr == null) {
                        JOptionPane.showMessageDialog(this, "Longitud no definida");
                    } else if (input.length() != longitudClavesSqr) {
                        JOptionPane.showMessageDialog(this,
                            "Todas las claves deben tener " + longitudClavesSqr + " dígitos",
                            "Longitud inválida",
                            JOptionPane.WARNING_MESSAGE);
                        return;
                    }

                    n = arraySqr.length;
                    index = middleSquareHash(key, n);

                    // 2. validar si la clave ya existe (no claves repetidas)
                    if (arraySqr[index] != null && arraySqr[index] == key) {
                        JOptionPane.showMessageDialog(this,
                            "La clave " + key + " ya existe en la tabla de " + metodoActual,
                            "Clave repetida",
                            JOptionPane.WARNING_MESSAGE);
                        return;
                    } else if (arraySqr[index] == null) {
                        // 3. insertar si no hay colisión
                        arraySqr[index] = key;
                        refreshCellsUI();
                        JOptionPane.showMessageDialog(this,
                            "Clave " + key + " insertada correctamente en " + metodoActual,
                            "Inserción exitosa",
                            JOptionPane.INFORMATION_MESSAGE);
                    } else {
                        refreshCellsUI();
                        JOptionPane.showMessageDialog(this,
                            "No se pudo insertar, colisión en la posición " + (index + 1) + " para " + metodoActual,
                            "Colisión",
                            JOptionPane.WARNING_MESSAGE);
                    }
                    break;
                case "H. Plegamiento":
                    if (arrayFold == null) {
                        JOptionPane.showMessageDialog(this, "Por Favor cree la Estructura para " 
                        + metodoActual, "Estructura no creada", JOptionPane.WARNING_MESSAGE);
                        return;
                    }

                    // 1. validar longitud de la clave
                    if (longitudClavesFold == null) {
                        JOptionPane.showMessageDialog(this, "Longitud no definida");
                    } else if (input.length() != longitudClavesFold) {
                        JOptionPane.showMessageDialog(this,
                            "Todas las claves deben tener " + longitudClavesFold + " dígitos",
                            "Longitud inválida",
                            JOptionPane.WARNING_MESSAGE);
                        return;
                    }

                    n = arrayFold.length;
                    index = foldingHash(key, n);

                    // 2. validar si la clave ya existe (no claves repetidas)
                    if (arrayFold[index] != null && arrayFold[index] == key) {
                        JOptionPane.showMessageDialog(this,
                            "La clave " + key + " ya existe en la tabla de " + metodoActual,
                            "Clave repetida",
                            JOptionPane.WARNING_MESSAGE);
                        return;
                    } else if (arrayFold[index] == null) {
                        // 3. insertar si no hay colisión
                        arrayFold[index] = key;
                        refreshCellsUI();
                        JOptionPane.showMessageDialog(this,
                            "Clave " + key + " insertada correctamente en " + metodoActual,
                            "Inserción exitosa",
                            JOptionPane.INFORMATION_MESSAGE);
                    } else {
                        refreshCellsUI();
                        JOptionPane.showMessageDialog(this,
                            "No se pudo insertar, colisión en la posición " + (index + 1) + " para " + metodoActual,
                            "Colisión",
                            JOptionPane.WARNING_MESSAGE);
                    }
                    break;
                case "H. Truncamiento":
                    if (arrayTrunk == null) {
                        JOptionPane.showMessageDialog(this, "Por Favor cree la Estructura para " 
                        + metodoActual, "Estructura no creada", JOptionPane.WARNING_MESSAGE);
                        return;
                    }

                    // 1. validar longitud de la clave
                    if (longitudClavesTrunk == null) {
                        JOptionPane.showMessageDialog(this, "Longitud no definida");
                    } else if (input.length() != longitudClavesTrunk) {
                        JOptionPane.showMessageDialog(this,
                            "Todas las claves deben tener " + longitudClavesTrunk + " dígitos",
                            "Longitud inválida",
                            JOptionPane.WARNING_MESSAGE);
                        return;
                    }

                    n = arrayTrunk.length;
                    index = truncationHash(key, n);

                    // 2. validar si la clave ya existe (no claves repetidas)
                    if (arrayTrunk[index] != null && arrayTrunk[index] == key) {
                        JOptionPane.showMessageDialog(this,
                            "La clave " + key + " ya existe en la tabla de " + metodoActual,
                            "Clave repetida",
                            JOptionPane.WARNING_MESSAGE);
                        return;
                    } else if (arrayTrunk[index] == null) {
                        // 3. insertar si no hay colisión
                        arrayTrunk[index] = key;
                        refreshCellsUI();
                        JOptionPane.showMessageDialog(this,
                            "Clave " + key + " insertada correctamente en " + metodoActual,
                            "Inserción exitosa",
                            JOptionPane.INFORMATION_MESSAGE);
                    } else {
                        refreshCellsUI();
                        JOptionPane.showMessageDialog(this,
                            "No se pudo insertar, colisión en la posición " + (index + 1) + " para " + metodoActual,
                            "Colisión",
                            JOptionPane.WARNING_MESSAGE);
                    }
                    break;
            }

        } catch (NumberFormatException ex) {
            JOptionPane.showMessageDialog(this, "Valor inválido", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    private void onSearch() {
        try {
            String metodoActual = hashCombo.getSelectedItem().toString();
            String input = txtKey.getText().trim();
            int key = Integer.parseInt(input);
            int n;
            int index;
            java.util.List<Integer> steps;
            int foundIndex;
            

            switch (metodoActual) {
                case "H. Mod":
                    // 1. validar longitud de la clave
                    if (longitudClavesMod == null) {
                    JOptionPane.showMessageDialog(this, "Longitud de claves no definida");
                    return;
                    } else if (input.length() != longitudClavesMod) {
                        JOptionPane.showMessageDialog(this,
                            "Todas las claves deben tener " + longitudClavesMod + " dígitos",
                            "Longitud inválida",
                            JOptionPane.WARNING_MESSAGE);
                        return;
                    }
                    clearHighlights();

                    n = arrayMod.length;
                    index = modHash(key, n);

                    steps = new java.util.ArrayList<>();
                    steps.add(index);

                    foundIndex = (arrayMod[index] != null && arrayMod[index] == key) ? index : -1;

                    animateSearch(steps, foundIndex);
                    break;

                case "H. Cuadrado":
                    // 1. validar longitud de la clave
                    if (longitudClavesSqr == null) {
                    JOptionPane.showMessageDialog(this, "Longitud de claves no definida");
                    return;
                    } else if (input.length() != longitudClavesSqr) {
                        JOptionPane.showMessageDialog(this,
                            "Todas las claves deben tener " + longitudClavesSqr + " dígitos",
                            "Longitud inválida",
                            JOptionPane.WARNING_MESSAGE);
                        return;
                    }
                    clearHighlights();

                    n = arraySqr.length;
                    index = middleSquareHash(key, n);

                    steps = new java.util.ArrayList<>();
                    steps.add(index);

                    foundIndex = (arraySqr[index] != null && arraySqr[index] == key) ? index : -1;

                    animateSearch(steps, foundIndex);
                    break;

                case "H. Plegamiento":
                    // 1. validar longitud de la clave
                    if (longitudClavesFold == null) {
                    JOptionPane.showMessageDialog(this, "Longitud de claves no definida");
                    return;
                    } else if (input.length() != longitudClavesFold) {
                        JOptionPane.showMessageDialog(this,
                            "Todas las claves deben tener " + longitudClavesFold + " dígitos",
                            "Longitud inválida",
                            JOptionPane.WARNING_MESSAGE);
                        return;
                    }
                    clearHighlights();

                    n = arrayFold.length;
                    index = foldingHash(key, n);

                    steps = new java.util.ArrayList<>();
                    steps.add(index);

                    foundIndex = (arrayFold[index] != null && arrayFold[index] == key) ? index : -1;

                    animateSearch(steps, foundIndex);
                    break;
                case "H. Truncamiento":
                    // 1. validar longitud de la clave
                    if (longitudClavesTrunk == null) {
                    JOptionPane.showMessageDialog(this, "Longitud de claves no definida");
                    return;
                    } else if (input.length() != longitudClavesTrunk) {
                        JOptionPane.showMessageDialog(this,
                            "Todas las claves deben tener " + longitudClavesTrunk + " dígitos",
                            "Longitud inválida",
                            JOptionPane.WARNING_MESSAGE);
                        return;
                    }
                    clearHighlights();

                    n = arrayTrunk.length;
                    index = truncationHash(key, n);

                    steps = new java.util.ArrayList<>();
                    steps.add(index);

                    foundIndex = (arrayTrunk[index] != null && arrayTrunk[index] == key) ? index : -1;

                    animateSearch(steps, foundIndex);
                    break;
                    
            }

        } catch (NumberFormatException ex) {
            JOptionPane.showMessageDialog(this, "Valor de búsqueda inválido", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }
    
    private void animateSearch(java.util.List<Integer> steps, int foundIndex) {
        clearHighlights();
        final int[] idx = {0};
        txtKey.setEnabled(false);

        Timer timer = new Timer(450, null);
        timer.addActionListener(_ -> {
            if (idx[0] >= steps.size()) {
                if (foundIndex == -1) {
                    JOptionPane.showMessageDialog(this,
                        "Valor no encontrado (colisión o nunca insertado)",
                        "Buscar",
                        JOptionPane.INFORMATION_MESSAGE);
                }
                txtKey.setEnabled(true);
                timer.stop();
                return;
            }

            int pos = steps.get(idx[0]);
            CellPanel cell = getCellPanel(pos);
            if (cell != null) {
                if (pos == foundIndex) {
                    // encontrado → verde
                    cell.setHighlight(MINT);
                    scrollCellToVisible(pos);
                    txtKey.setEnabled(true);
                    timer.stop();
                    return;
                } else {
                    // descartado → rojo
                    cell.setHighlight(Color.RED);
                    scrollCellToVisible(pos);
                }
            }
            idx[0]++;
        });

        timer.setInitialDelay(0);
        timer.start();
    }

    private void animateDelete(java.util.List<Integer> steps, int foundIndex, Runnable onFinished) {
        clearHighlights();
        final int[] idx = {0};
        txtKey.setEnabled(false);

        Timer timer = new Timer(400, null);
        timer.addActionListener(_ -> {
            if (idx[0] >= steps.size()) {
                if (foundIndex == -1) {
                    JOptionPane.showMessageDialog(this,
                        "Valor no encontrado (colisión o nunca insertado)",
                        "Buscar",
                        JOptionPane.INFORMATION_MESSAGE);
                }
                txtKey.setEnabled(true);
                timer.stop();

                // ✅ LLAMAR AL CALLBACK CUANDO TERMINA LA ANIMACIÓN
                if (onFinished != null) {
                    onFinished.run();
                }
                return;
            }

            int pos = steps.get(idx[0]);
            CellPanel cell = getCellPanel(pos);
            if (cell != null) {
                if (pos == foundIndex) {
                    // encontrado → verde
                    cell.setHighlight(MINT);
                    scrollCellToVisible(pos);
                    txtKey.setEnabled(true);
                    timer.stop();

                    // ✅ TAMBIÉN LLAMAR AL CALLBACK CUANDO ENCUENTRA EL ELEMENTO
                    if (onFinished != null) {
                        onFinished.run();
                    }
                    return;
                } else {
                    // descartado → rojo
                    cell.setHighlight(Color.RED);
                    scrollCellToVisible(pos);
                }
            }
            idx[0]++;
        });

        timer.setInitialDelay(0);
        timer.start();
    }

    private void onDelete() {
        try {
            String metodoActual = hashCombo.getSelectedItem().toString();
            int key = Integer.parseInt(txtKey.getText().trim());
            int n;
            int index;
            java.util.List<Integer> steps;
            int foundIndex;

            switch (metodoActual) {
                case "H. Mod":
                    n = arrayMod.length;
                    index = modHash(key, n);

                    if (arrayMod[index] != null && arrayMod[index] == key) {
                        arrayMod[index] = null;
                        refreshCellsUI();
                        JOptionPane.showMessageDialog(this, 
                            "Clave " + key + " eliminada de la posición " + (index + 1),
                            "Eliminado",
                            JOptionPane.INFORMATION_MESSAGE);
                    } else {
                        JOptionPane.showMessageDialog(this, 
                            "La clave " + key + " no se encuentra en la tabla",
                            "No encontrado",
                            JOptionPane.WARNING_MESSAGE);
                    }
                    clearHighlights();

                    steps = new java.util.ArrayList<>();
                    steps.add(index);

                    foundIndex = (arrayMod[index] != null && arrayMod[index] == key) ? index : -1;

                    animateDelete(steps, foundIndex, () -> {
                        if (foundIndex != -1) {
                            arrayMod[foundIndex] = null;
                            refreshCellsUI();
                            JOptionPane.showMessageDialog(this,
                                "Clave " + key + " eliminada de la posición " + (foundIndex + 1),
                                "Eliminado",
                                JOptionPane.INFORMATION_MESSAGE);
                        } else {
                            JOptionPane.showMessageDialog(this,
                                "La clave " + key + " no se encuentra en la tabla",
                                "No encontrado",
                                JOptionPane.WARNING_MESSAGE);
                        }
                    });
                    break;
                case "H. Cuadrado":
                    n = arraySqr.length;
                    index = middleSquareHash(key, n);

                    if (arraySqr[index] != null && arraySqr[index] == key) {
                        arraySqr[index] = null;
                        refreshCellsUI(); //cuando inserte colisiones talvez deba quitar esto de aca
                        JOptionPane.showMessageDialog(this, 
                            "Clave " + key + " eliminada de la posición " + (index + 1),
                            "Eliminado",
                            JOptionPane.INFORMATION_MESSAGE);
                    } else {
                        JOptionPane.showMessageDialog(this, 
                            "La clave " + key + " no se encuentra en la tabla",
                            "No encontrado",
                            JOptionPane.WARNING_MESSAGE);
                    }
                    clearHighlights();

                    steps = new java.util.ArrayList<>();
                    steps.add(index);

                    foundIndex = (arraySqr[index] != null && arraySqr[index] == key) ? index : -1;

                    animateDelete(steps, foundIndex, () -> {
                        if (foundIndex != -1) {
                            arraySqr[foundIndex] = null;
                            refreshCellsUI();
                            JOptionPane.showMessageDialog(this,
                                "Clave " + key + " eliminada de la posición " + (foundIndex + 1),
                                "Eliminado",
                                JOptionPane.INFORMATION_MESSAGE);
                        } else {
                            JOptionPane.showMessageDialog(this,
                                "La clave " + key + " no se encuentra en la tabla",
                                "No encontrado",
                                JOptionPane.WARNING_MESSAGE);
                        }
                    });
                    break;
                case "H. Plegamiento":
                    n = arrayFold.length;
                    index = foldingHash(key, n);

                    if (arrayFold[index] != null && arrayFold[index] == key) {
                        arrayFold[index] = null;
                        refreshCellsUI(); //cuando inserte colisiones talvez deba quitar esto de aca
                        JOptionPane.showMessageDialog(this, 
                            "Clave " + key + " eliminada de la posición " + (index + 1),
                            "Eliminado",
                            JOptionPane.INFORMATION_MESSAGE);
                    } else {
                        JOptionPane.showMessageDialog(this, 
                            "La clave " + key + " no se encuentra en la tabla",
                            "No encontrado",
                            JOptionPane.WARNING_MESSAGE);
                    }
                    clearHighlights();

                    steps = new java.util.ArrayList<>();
                    steps.add(index);

                    foundIndex = (arrayFold[index] != null && arrayFold[index] == key) ? index : -1;

                    animateDelete(steps, foundIndex, () -> {
                        if (foundIndex != -1) {
                            arrayFold[foundIndex] = null;
                            refreshCellsUI();
                            JOptionPane.showMessageDialog(this,
                                "Clave " + key + " eliminada de la posición " + (foundIndex + 1),
                                "Eliminado",
                                JOptionPane.INFORMATION_MESSAGE);
                        } else {
                            JOptionPane.showMessageDialog(this,
                                "La clave " + key + " no se encuentra en la tabla",
                                "No encontrado",
                                JOptionPane.WARNING_MESSAGE);
                        }
                    });
                    break;
                case "H. Truncamiento":
                    n = arrayTrunk.length;
                    index = truncationHash(key, n);

                    if (arrayTrunk[index] != null && arrayTrunk[index] == key) {
                        arrayTrunk[index] = null;
                        refreshCellsUI(); //cuando inserte colisiones talvez deba quitar esto de aca
                        JOptionPane.showMessageDialog(this, 
                            "Clave " + key + " eliminada de la posición " + (index + 1),
                            "Eliminado",
                            JOptionPane.INFORMATION_MESSAGE);
                    } else {
                        JOptionPane.showMessageDialog(this, 
                            "La clave " + key + " no se encuentra en la tabla",
                            "No encontrado",
                            JOptionPane.WARNING_MESSAGE);
                    }
                    clearHighlights();

                    steps = new java.util.ArrayList<>();
                    steps.add(index);

                    foundIndex = (arrayTrunk[index] != null && arrayTrunk[index] == key) ? index : -1;

                    animateDelete(steps, foundIndex, () -> {
                        if (foundIndex != -1) {
                            arrayTrunk[foundIndex] = null;
                            refreshCellsUI();
                            JOptionPane.showMessageDialog(this,
                                "Clave " + key + " eliminada de la posición " + (foundIndex + 1),
                                "Eliminado",
                                JOptionPane.INFORMATION_MESSAGE);
                        } else {
                            JOptionPane.showMessageDialog(this,
                                "La clave " + key + " no se encuentra en la tabla",
                                "No encontrado",
                                JOptionPane.WARNING_MESSAGE);
                        }
                    });
                break;
            }
        } catch (NumberFormatException ex) {
            JOptionPane.showMessageDialog(this, "Clave inválida", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }
    
    // --------- UI: refresco y utilidades ----------
    private Integer[] getArray() {
        String metodoActual = hashCombo.getSelectedItem().toString();
        switch (metodoActual) {
            case "H. Mod":
                return arrayMod;
            case "H. Cuadrado":
                return arraySqr;
            case "H. Plegamiento":
                return arrayFold;
            case "H. Truncamiento":
                return arrayTrunk;
            default:
                return null;

        }
    }

    private void setIcon() {
        String metodoActual = hashCombo.getSelectedItem().toString();
        switch (metodoActual) {
            case "H. Mod":
                logo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Assets/HashModTitle.png")));
                break;
            case "H. Cuadrado":
                logo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Assets/HashMidSquareTitle.png")));
                break;
            case "H. Plegamiento":
                logo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Assets/HashFoldingTitle.png")));
                break;
            case "H. Truncamiento":
                logo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Assets/HashTruncationTitle.png")));
                break;
        
        }
    }

    private void refreshCellsUI() {
        Integer[] array = getArray();
        if (array == null) {
            panelCells.removeAll();
            panelCells.revalidate();
            panelCells.repaint();
            return;
        }
        panelCells.removeAll();
        panelCells.add(Box.createRigidArea(new Dimension(8, 0)));
        for (int i=0;i<array.length;i++) {
            CellPanel cell = new CellPanel(i + 1, array[i]);
            panelCells.add(cell);
            
        }
        panelCells.revalidate();
        panelCells.repaint();
    }

    private CellPanel getCellPanel(int index) {
        Component comp = getCellComponent(index);
        return (comp instanceof CellPanel) ? (CellPanel) comp : null;
    }

    private void clearHighlights() {
        for (Component c : panelCells.getComponents()) {
            if (c instanceof CellPanel) {
                ((CellPanel)c).setHighlight(null);
            }
        }
    }

    private void scrollCellToVisible(int index) {
        Component comp = getCellComponent(index);
        if (comp != null) {
            Rectangle r = comp.getBounds();
            JViewport v = scrollPaneCells.getViewport();
            Rectangle viewRect = v.getViewRect();
            r.x = Math.max(0, r.x - (viewRect.width - r.width)/2);
            v.scrollRectToVisible(r);
        }
    }

    private Component getCellComponent(int index) {
        int compIndex = index + 1; // la del margen
        if (compIndex >= 0 && compIndex < panelCells.getComponentCount()) {
            return panelCells.getComponent(compIndex);
        }
        return null;
    }
    
    
    // --------- Clase interna para la celda ----------
    private class CellPanel extends JPanel {
        private JLabel posLabel;
        private JLabel valLabel;

        public CellPanel(int position, Integer value) {
            setLayout(new BorderLayout());
            setPreferredSize(new Dimension(CELL_WIDTH, CELL_HEIGHT));
            setMaximumSize(new Dimension(CELL_WIDTH, CELL_HEIGHT));
            setBackground(new Color(0,0,0,0));
            setOpaque(false);
            setBorder(new LineBorder(Color.black, 1, true));

            posLabel = new JLabel(String.valueOf(position), SwingConstants.CENTER);
            posLabel.setForeground(LABEL_BLACK);
            posLabel.setFont(getFont().deriveFont(Font.PLAIN, 12f));
            posLabel.setOpaque(false);
            posLabel.setBorder(BorderFactory.createEmptyBorder(4,4,0,4));

            valLabel = new JLabel(value == null ? "" : String.valueOf(value), SwingConstants.CENTER);
            valLabel.setForeground(LABEL_BLACK);
            valLabel.setFont(getFont().deriveFont(Font.BOLD, 18f));
            valLabel.setOpaque(false);
            valLabel.setBorder(BorderFactory.createEmptyBorder(0,4,6,4));

            add(posLabel, BorderLayout.NORTH);
            add(valLabel, BorderLayout.CENTER);
        }

        /**
         * General highlight method:
         * - bgColor != null -> apply background color (and choose text color depending on bg)
         * - bgColor == null -> reset to default (transparent + white labels)
         */
        public void setHighlight(Color bgColor) {
            if (bgColor != null) {
                setOpaque(true);
                setBackground(bgColor);
                // texto en negro para mint (mejor contraste) y en blanco para rojo u otros fondos oscuros
                if (Color.RED.equals(bgColor)) {
                    posLabel.setForeground(Color.WHITE);
                    valLabel.setForeground(Color.WHITE);
                } else {
                    posLabel.setForeground(Color.BLACK);
                    valLabel.setForeground(Color.BLACK);
                }
            } else {
                resetHighlight();
            }
            repaint();
        }

        private void resetHighlight() {
            setOpaque(false);
            setBackground(new Color(0,0,0,0));
            posLabel.setForeground(LABEL_BLACK);
            valLabel.setForeground(LABEL_BLACK);
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel backGround;
    private javax.swing.JButton btnCreate;
    private javax.swing.JButton btnDelete;
    private javax.swing.JButton btnInsert;
    private javax.swing.JButton btnOpen;
    private javax.swing.JButton btnSave;
    private javax.swing.JButton btnSearch;
    private javax.swing.JPanel dragPanel;
    private javax.swing.JComboBox<String> hashCombo;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JLabel logo;
    private javax.swing.JPanel panelCells;
    private javax.swing.JScrollPane scrollPaneCells;
    private javax.swing.JTextField sizeArrayField;
    private javax.swing.JTextField sizeKeyField;
    private javax.swing.JLabel txtArraySize;
    private javax.swing.JTextField txtKey;
    private javax.swing.JLabel txtKeySize;
    private javax.swing.JLabel txtValor;
    private javax.swing.JLabel volverTxt;
    // End of variables declaration//GEN-END:variables
}
